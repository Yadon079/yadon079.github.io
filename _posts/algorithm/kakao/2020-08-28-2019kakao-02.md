---
layout: post
date: 2020-08-28 20:53:22
title: "[JAVA]크레인 인형뽑기 게임"
description: "2019 카카오 개발자 겨울 인턴십"
subject: kakao
category: [ coding test ]
tags: [ algorithm, java, kakao ]
comments: true
---

# 크레인 인형뽑기 게임

> [문제 풀러가기](https://programmers.co.kr/learn/courses/30/lessons/64061)

## 문제 설명

&nbsp; 게임개발자인 "죠르디"는 크레인 인형뽑기 기계를 모바일 게임으로 만들려고 한다.
"죠르디"는 게임의 재미를 높이기 위해 화면 구성과 규칙을 다음과 같이 게임 로직에 반영하려고 합니다.

![01](/assets/img/cote/crane_game_101.png)

게임 화면은 **"1 x 1"** 크기의 칸들로 이루어진 **"N x N"** 크기의 정사각 격자이며 위쪽에는 크레인이 있고 오른쪽에는 바구니가 있습니다. (위 그림은 "5 x 5" 크기의 예시입니다) 각 격자 칸에는 다양한 인형이 들어 있으며 인형이 없는 칸은 빈칸입니다. 모든 인형은 "1 x 1" 크기의 격자 한 칸을 차지하며 **격자의 가장 아래 칸부터 차곡차곡 쌓여 있습니다**. 게임 사용자는 크레인을 좌우로 움직여서 멈춘 위치에서 가장 위에 있는 인형을 집어 올릴 수 있습니다. 집어 올린 인형은 바구니에 쌓이게 되는 데, 이때 바구니의 가장 아래 칸부터 인형이 순서대로 쌓이게 됩니다. 다음 그림은 [1번, 5번, 3번] 위치에서 순서대로 인형을 집어 올려 바구니에 담은 모습입니다.

![02](/assets/img/cote/crane_game_102.png)

만약 같은 모양의 인형 두 개가 바구니에 연속해서 쌓이게 되면 두 인형은 터뜨려지면서 바구니에서 사라지게 됩니다. 위 상태에서 이어서 [5번] 위치에서 인형을 집어 바구니에 쌓으면 같은 모양 인형 **두 개**가 없어집니다.

![03](/assets/img/cote/crane_game_103.gif)

크레인 작동 시 인형이 집어지지 않는 경우는 없으나 만약 인형이 없는 곳에서 크레인을 작동시키는 경우에는 아무런 일도 일어나지 않습니다. 또한 바구니는 모든 인형이 들어갈 수 있을 만큼 충분히 크다고 가정합니다. (그림에서는 화면표시 제약으로 5칸만으로 표현하였음)

&nbsp; 게임 화면의 격자의 상태가 담긴 2차원 배열 board와 인형을 집기 위해 크레인을 작동시킨 위치가 담긴 배열 moves가 매개변수로 주어질 때, 크레인을 모두 작동시킨 후 터트려져 사라진 인형의 개수를 return 하도록 solution 함수를 완성해주세요.

**[제한사항]**

+ board 배열은 2차원 배열로 크기는 "5 x 5" 이상 "30 x 30" 이하입니다.
+ board의 각 칸에는 0 이상 100 이하인 정수가 담겨있습니다.
  + 0은 빈 칸을 나타냅니다.
  + 1 ~ 100의 각 숫자는 각기 다른 인형의 모양을 의미하며 같은 수자는 같은 모양의 인형을 나타냅니다.
+ moves 배열의 크기는 1 이상 1,000 이하입니다.
+ moves 배열 각 원소들의 값은 1 이상이며 board 배열의 가로 크기 이하인 자연수입니다.

## 입출력 예

| board | &nbsp;&nbsp;&nbsp; | moves | &nbsp;&nbsp;&nbsp; | result |
|:---|:---:|:---|:---:|:---|
| \[[0, 0, 0, 0, 0], [0, 0, 1, 0, 3], [0, 2, 5, 0, 1], [4, 2, 4, 4, 2], [3, 5, 1, 3, 1]] || [1, 5, 3, 5, 1, 2, 1, 4] || 4 |

## 입출력 예에 대한 설명

**입출력 예 #1**

&nbsp; 인형의 처음 상태는 문제에 주어진 예시와 같습니다. 크레인이 [1, 5, 3, 5, 1, 2, 1, 4]번 위치에서 차례대로 인형을 집어서 바구니에 옮겨 담은 후, 상태는 아래 그림과 같으며 바구니에 담는 과정에서 터트려져 사라진 인형은 4개 입니다.

![04](/assets/img/cote/crane_game_104.jpg)

---

## 코드

```java
import java.util.*;

class Solution {
  public int solution(int[][] board, int[] moves) {
    int answer = 0;
    Stack<Integer> s = new Stack<>();

    for(Integer move : moves) {
      int mvIdx = move - 1;
      for(int i = 0; i < board.length; i++) {
        int j = board[i][mvIdx];

        if(j == 0) {
          continue;
        }

        if(!s.empty() && s.peek() == j) {
          s.pop();
          answer++;
        } else {
          s.push(j);
        }

        board[i][mvIdx] = 0;
        break;
      }
    }

    return answer * 2;
  }
}
```

## 설명

&nbsp; 0이 아닌 위치까지 탐색하도록 만들어서 인형을 발견하면 위치를 0으로 하고 바구니에 담는 식으로 하면 된다. 처음에는 배열을 이용해서 하나씩 탐색하고 바꾸는 식으로 구현했다가 `stack`을 이용하는 방법으로 다시 만들었다.

&nbsp; 크레인의 구조를 보면 아래로 이동한다. 이 말은 for문을 돌지만 move 인덱스는 고정된 채 돌아야한다는 말이다. 그리고 moves의 값은 1부터 시작하지만 인덱스는 0부터 시작하므로 1을 뺀 값을 인덱스로 선언한다. 해당 자리의 값이 0이면 아래로 이동하도록 해야한다.

```java
    for(Integer move : moves) {
      int mvIdx = move - 1;
      for(int i = 0; i < board.length; i++) {
        int j = board[i][mvIdx];

        if(j == 0) {
          continue;
        }
```

이 후 숫자가 나오면 스택의 `top`을 검사해서 `top`이 비어있거나 `j`와 다르면 `j`값을 `top`에 입력한다. 반대로 `top`이 비어있지않고 `j`와 같다면 `top`에 들어있는 값을 지우고 터트려져 사라진 인형의 개수인 `answer`의 값을 1 증가시킨다.

```java
        if(!s.empty() && s.peek() == j) {
          s.pop();
          answer++;
        } else {
          s.push(j);
        }
```

그리고 인형이 이동하였으므로 그 위치는 0으로 변환해준 후 다음 위치로 크레인을 이동한다. 모든 이동이 끝난 후 터트려져 사라진 인형의 개수를 출력할 때 인형은 한 번 사라질 때 2개씩 사라지므로 2를 곱해서 출력한다.

```java
        board[i][mvIdx] = 0;
        break;
      }
    }

    return answer * 2;
  }
}
```
