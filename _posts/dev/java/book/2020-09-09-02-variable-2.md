---
layout: post
date: 2020-09-09 10:00:00
title: "변수 Variable 2편"
description: "자바의 정석"
subject: java의 정석
category: [ java ]
tags: [ java, variable]
comments: true
---

# 변수 Variable

> 이 글은 남궁성님의 [자바의 정석 3/e](http://www.kyobobook.co.kr/product/detailViewKor.laf?mallGb=KOR&ejkGb=KOR&barcode=9788994492032)을 기반으로 공부한 내용을 정리한 글입니다.

+ [진법](#진법)
+ [기본형(primitive type](#기본형)

## 진법

### 3.1 10진법과 2진법

대부분의 컴퓨터는 2진 체계로 설계되었기 때문에, 2진법을 알지 못하면 컴퓨터의 동작원리나 데이터 처리방식을 이해하기 어렵다. 변수에 값이 저장될 때 컴퓨터는 2진수 밖에 모르기 때문에 10진수가 2진수로 바뀌어 저장된다.

2진법은 0과 1로만 데이터를 표현하기 때문에 10진법에 비해 많은 자리수가 필요하다. 10진수 2와 같이 작은 숫자도 2진수로 표현하려면 2자리가 필요하다.

| <center>2진수 | <center>10진수 |
|---:|---:|
| 0 | 0 |
| 1 | 1 |
| 10 | 2 |
| 11 | 3 |
| 100 | 4 |
| 101 | 5 |
| 110 | 6 |
| 111 | 7 |
| 1000 | 8 |
| 1001 | 9 |
| 1010 | 10 |

<br/>
### 3.2 비트(bit)와 바이트(byte)

'비트(bit, <b>bi</b>nary digi<b>t</b>)'는 한 자리의 2진수를 가리키는 말이며, 1 비트는 컴퓨터가 값을 저장할 수 있는 최소단위이다. '바이트(byte)'는 데이터의 기본 단위로 사용되며 1 비트 8개를 묶은 것이다.

| <center>1 bit(2개) | <center>2 bit(4개) | <center>3 bit(8개) | <center>4 bit(16개) | <center>10진수 |
|---:|---:|---:|---:|---:|
| 0 | 00 | 000 | 0000 | 0 |
| 1 | 01 | 001 | 0001 | 1 |
|  | 10 | 010 | 0010 | 2 |
|  | 11 | 011 | 0011 | 3 |
|  |  | 100 | 0100 | 4 |
|  |  | 101 | 0101 | 5 |
|  |  | 110 | 0110 | 6 |
|  |  | 111 | 0111 | 7 |
|  |  |  | 1000 | 8 |
|  |  |  | 1001 | 9 |
|  |  |  | 1010 | 10 |
|  |  |  | 1011 | 11 |
|  |  |  | 1100 | 12 |
|  |  |  | 1101 | 13 |
|  |  |  | 1110 | 14 |
|  |  |  | 1111 | 15 |

<br/>
이를 일반화하면, n비트로 2<sup>n</sup>개의 값을 표현할 수 있다. 그리고 n 비트로 표현가능한 10진수의 범위는 0 ~ 2<sup>n</sup> - 1이 된다.

> <p style="font-size:15px"><b>n비트로 표현할 수 있는 10진수</b><br/>값의 개수 : 2<sup>n</sup><br/>값의 범위 : 0 ~ 2<sup>n</sup> - 1</p>

<span style="font-size:13px">
<b>| 참고 | 10진수 n자리로 표현할 수 있는 값의 범위가 '0 ~ 10<sup>n</sup>-1'라는 것을 생각해보면 이해하기 쉽다.<br/></b>
</span>

### 3.3 8진법과 16진법

2진법은 0과 1, 두 개의 기호만으로 값을 표현하기 때문에 자리수가 길어진다는 단점이 있다. 이를 보완하기 위해 8진법이나 16진법을 사용한다.

<b>8진수는 2진수 3자리, 16진수는 2진수 4자리를 각각 한자리로 표현할 수 있어서 자리수가 짧아져 알아보기 쉽고 서로 간의 변환방법 또한 간단하다.</b>

| <center>2진수 | <center>8진수 | <center>10진수 | <center>16진수 |
|---:|---:|---:|---:|
| 0 | 0 | 0 | 0 |
| 1 | 1 | 1 | 1 |
| 10 | 2 | 2 | 2 |
| 11 | 3 | 3 | 3 |
| 100 | 4 | 4 | 4 |
| 101 | 5 | 5 | 5 |
| 110 | 6 | 6 | 6 |
| 111 | 7 | 7 | 7 |
| 1000 | 10 | 8 | 8 |
| 1001 | 11 | 9 | 9 |
| 1010 | 12 | 10 | A |
| 1011 | 13 | 11 | B |
| 1100 | 14 | 12 | C |
| 1101 | 15 | 13 | D |
| 1110 | 16 | 14 | E |
| 1111 | 17 | 15 | F |
| 10000 | 20 | 16 | 10 |

<br/>
8진법은 값을 표현하는데 8개의 기호가 필요하므로 0~7의 숫자를 사용하지만, 16진법은 16개가 필요하다. 숫자만으로는 부족하므로 6개의 문자(A~F)를 추가로 사용한다.   

<p style="color:#a0adec"><b>2진수를 8진수, 16진수로 변환</b></p>

2진수를 8진수로 변환하려면, 2진수를 뒤에서부터 3자리씩 끊어서 그에 해당하는 8진수로 바꾸면 된다. 8은 2<sup>3</sup>이기 때문에, 8진수 한 자리가 2진수 3자리를 대신할 수 있는 것이다. 마찬가지로 16진수 변환은 4자리씩 끊어서 변환하면 된다.

### 3.4 정수의 진법 변환

<p style="color:#a0adec"><b>2진수를 8진수, 16진수로 변환</b></p>

10진수를 다른 진수로 변환하려면, 해당 진수로 더 이상 나눌 수 없을 때까지 나눈 뒤 몫과 나머지를 아래에서 위로 적으면 된다. n진수로 변환하려면, n으로 반복해서 나누기만 하면 되는 것이다.

<p style="color:#a0adec"><b>n진수를 10진수로 변환</b></p>

어떤 진법의 수라도 10진수로 변환하는 방법은 똑같다. 각 자리의 수에 해당 단위의 값을 곱해 모두 더하면 된다. 예를 들어 2진수 `101110`의 경우 각 자리의 단위가 2의 제곱이므로 이를 곱해주면 `32 + 0 + 8 + 4 + 2 + 0` 이므로 `46`이 된다.

### 3.5 실수의 진법 변환

<p style="color:#a0adec"><b>10진 소수점수를 2진 소수점수로 변환하는 방법</b></p>

10진 소수점수를 2진 소수점수로 변환하는 방법은 정수와 반대로 10진 소수점수에 2를 계속 곱한다. 그 결과에서 정수부만을 위에서 아래 순서대로 적고 '0.'을 붙이면 된다.

<p style="color:#a0adec"><b>2진 소수점수를 10진 소수점수로 변환하는 방법</b></p>

0.101<sub>(2)</sub>의 경우 각 자리 단위를 곱하면 <b>1 x 2<sup>-1</sup> + 0 x 2<sup>-2</sup> + 1 x 2<sup>-3</sup> = 1 x 0.5 + 0 x 0.25 + 1 x 0.125 = 0.625<sub>(10)</sub></b>이다.

### 3.6 음수의 2진 표현 - 2의 보수법

n비트의 2진수로 표현할 수 있는 값의 개수는 모두 2<sup>n</sup>개이므로, 4비트의 2진수로는 16개의 값을 표현할 수 있다. 이 값을 모두 '부호없는 정수(0과 양수)'의 표현에 사용하면 **0부터 15까지의 정수**를 나타낼 수 있다.

4비트의 2진수로 부호있는 정수, 즉 양수와 음수를 모두 표현할 때는 **왼쪽의 첫 번째 비트(MSB)**가 0이면 양수, 1이면 음수이다.

| <center># | <center>2진수 | 부호있는 10진수 |
|---:|---:|---:|
| 1 | 0000 | 0 |
| 2 | 0001 | 1 |
| 3 | 0010 | 2 |
| 4 | 0011 | 3 |
| 5 | 0100 | 4 |
| 6 | 0101 | 5 |
| 7 | 0110 | 6 |
| 8 | 0111 | 최대값 -> 7 |
| 9 | 1000 | -0 |
| 10 | 1001 | -1 |
| 11 | 1010 | -2 |
| 12 | 1011 | -3 |
| 13 | 1100 | -4 |
| 14 | 1101 | -5 |
| 15 | 1110 | -6 |
| 16 | 1111 | 최소값 -> -7 |

<br/>
위와 같은 경우, 양수의 첫 번째 비트만 1로 바꾸면 음수가 된다는 장점이 있다. 하지만 두 수를 더했을 때 2진수로 0이 되지 않고, 0이 두 개(0, -0) 존재한다는 단점이 있다. 그리고 2진수가 증가할 때 10진 음수는 감소한다.

| <center># | <center>2진수 | 부호있는 10진수 |
|---:|---:|---:|
| 1 | 0000 | 0 |
| 2 | 0001 | 1 |
| 3 | 0010 | 2 |
| 4 | 0011 | 3 |
| 5 | 0100 | 4 |
| 6 | 0101 | 5 |
| 7 | 0110 | 6 |
| 8 | 0111 | 최대값 -> 7 |
| 9 | 1000 | 최소값 -> -8 |
| 10 | 1001 | -7 |
| 11 | 1010 | -6 |
| 12 | 1011 | -5 |
| 13 | 1100 | -4 |
| 14 | 1101 | -3 |
| 15 | 1110 | -2 |
| 16 | 1111 | -1 |

<br/>
위와 같이 **2의 보수법**에 의해 음수를 배치하면, 절대값이 같은 양수와 음수를 더 했을 때 2진수로도 0의 결과를 얻으므로 부호를 신경쓰지 않고 덧셈할 수 있게 된다. 그리고 2진수가 증가할 때 10진 음수가 감소한다는 모순도 없어진다. 단, 첫 번째 비트를 바꿔서 값의 부호를 바꾸는 것은 할 수 없게 되었다.

<p style="color:#a0adec"><b>2의 보수법</b></p>

어떤 수의 'n의 보수'는 **더했을 때 n이 되는 수**를 말한다. '2의 보수 관계'는 더해서 2가 되는 두 수의 관계를 말하며 10진수 2는 2진수로 `10`이다. 2진수로 `10`은 **자리올림이 발생하고 0이 되는 수**를 뜻한다. 그래서 '2의 보수 관계'에 있는 두 2진수를 더하면 자리올림이 발생하고 0이 된다.

2진수 `0101`과 `1011`은 서로 '2의 보수 관계'에 있으며, 이 두 2진수를 더하면 0이 된다.

이처럼 서로 '2의 보수 관계'에 있는 두 2진수로 절대값이 같고 부호가 다른 두 10진수를 표현하는 것을 **2의 보수법**이라고 한다.

<p style="color:#a0adec"><b>음수를 2진수로 표현하기</b></p>

10진 음의 정수를 2진수로 변환하려면, 먼저 10진 음의 정수의 절대값을 2진수로 변환한다. 그 다음에 이 2진수의 '2의 보수'를 구하면 된다. 예를 들어 '-5'의 2진 표현을 구하는 과정은 다음과 같다.

<center>-5<sub>10</sub> --절대값--> 5<sub>10</sub> --2진수--> 0101<sub>(2)</sub> --2의보수--> 1011<sub>(2)</sub></center>

위 방법은 부호가 다르고 절대값이 같은 두 정수의 2진 표현이 서로 **2의 보수**관계에 있다는 것을 이용한 것이다.

<p style="color:#a0adec"><b>2의 보수 구하기</b></p>

'2의 보수'의 관계에 있는 두 수를 더하면 '0(자리올림 발생)'이 된다. 즉, '2의 보수'를 구하려면 어떤 수를 더하면 0이 되는지를 알아내야 한다. 뺄셈으로 간단히 구할 수 있지만 자리수가 많아지면 뺄셈도 어려워진다. 다행히 더 간단히 구하는 방법이 있는데, 바로 '1의 보수'를 구한 다음 1을 더하면 '2의 보수'가 구해지는 것이다.

<center><b>2의 보수 = 1의 보수 + 1</b></center>

'1의 보수'는 **0을 1로, 1을 0으로** 바꾸면 되므로 구하기가 쉽다. 예를 들어, 2진수 `0101`의 '1의 보수'는 `1010`이고 여기에 1을 더하면 `1011`로 '2의 보수'가 구해지는 것이다.

<p style="color:#a0adec"><b>왜 '1의 보수 + 1'은 '2의 보수'인가?</b></p>

어떤 2진수가 있을 때, 이 2진수의 1의 보수를 더하면 모든 자리가 1이 된다.

<table align="center"><tr><td>0</td><td>1</td><td>0</td><td>1</td><td style="border-top:0px; border-bottom:0px">+</td><td>1</td><td>0</td><td>1</td><td>0</td><td style="border-top:0px; border-bottom:0px">=</td><td>1</td><td>1</td><td>1</td><td>1</td></tr></table>

위 식에서 양변에 1을 더하면 우변은 0이 된다. 올림(carry)이 발생하지만 4비트를 넘는 값이라 버려진다.
