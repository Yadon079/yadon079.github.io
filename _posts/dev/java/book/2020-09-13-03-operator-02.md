---
layout: post
date: 2020-09-13 00:02:00
title: "연산자 Operator 2편"
description: "자바의 정석"
subject: java의 정석
category: [ java ]
tags: [ java, variable]
comments: true
---

# 연산자 Operator

> 이 글은 남궁성님의 [자바의 정석 3/e](http://www.kyobobook.co.kr/product/detailViewKor.laf?mallGb=KOR&ejkGb=KOR&barcode=9788994492032)을 기반으로 공부한 내용을 정리한 글입니다.

+ [비교 연산자](#비교-연산자)
+ [논리 연산자](#논리-연산자)
+ [그 외의 연산자](#그-외의-연산자)

## 비교 연산자

비교 연산자는 두 피연산자를 비교하는 데 사용되는 연산자이다. 주로 조건문과 반복문의 조건식에 사용되며, 연산결과는 오직 true와 false 둘 중의 하나이다. 비교 연산자 역시 이항 연산자이므로 타입 다를 경우 자동 형변환을 한다.

### 4.1 대소비교 연산자 < > <= >=

두 피연산자의 크기를 비교하는 연산자이다. 참이면 ture, 거짓이면 false를 반환한다. 기본형 중에서 boolean형을 제외한 나머지 자료형에 다 사용할 수 있지만 참조형에는 사용할 수 없다.

### 4.2 등가비교 연산자 == !=

두 피연산자의 값이 같은지 다른지를 비교하는 연산자이다. 대소비교 연산자와 달리 모든 자료형에 사용할 수 있다. 기본형은 변수에 저장되어 있는 값을 비교하고, 참조형은 두 개의 피연산자(참조변수)가 같은 객체를 가리키고 있는지 알 수 있다. 기본형과 참조형을 서로 비교할 수 없다.

<span style="font-size:13px; color:red">
! 주의 ! 두 개의 기호로 이루어진 연산자(>=, <=)는 기호의 순서를 바꾸거나, 공백이 들어가서는 안 된다.<br/>
</span>  

```java
class Operator {
  public static void main(String[] args) {
    float f = 0.1f;

    System.out.println("0.1 == 0.1f  %b", 0.1 == 0.1f);
  }
}
```

위 예제를 실행하면 결과 값은 `true`가 아닌 `false`가 나온다. 왜냐하면 실수형은 정수형과 달리 근사값으로 저장되기 때문에 오차가 발생하는 것이다. `double`타입으로 형변환해도 마찬가지인데, 이는 정밀도가 더 높은 `double`타입으로 변환해도 부호와 지수는 달라지지 않고 가수의 빈자리만 0으로 채우기 때문이다.

`float`타입의 값과 `double`타입의 값을 비교하려면 `double`타입의 값을 `float`타입의 값으로 형변환하여 비교해야 한다.

<p style="color:#a0adec"><b>문자열의 비교</b></p>

두 문자열의 비교할 때는, 비교 연산자가 아닌 `equals()`라는 메서드를 사용해야 한다. 비교 연산자는 두 문자열이 완전히 같은 것인지 비교할 뿐이므로, 문자열의 내용이 같은지 비교하기 위해서는 `equals()`를 사용해야 한다.

`equals()`는 객체가 달라도 내용이 같으면 `true`를 반환한다. 대소문자 구분없이 비교하고 싶으면, `equalsIgnoreCase()`를 사용하면 된다.

[위로](#연산자-operator)

## 논리 연산자

논리 연산자는 둘 이상의 조건을 '그리고(AND)'나 '또는(OR)'으로 연결하여 하나의 식으로 표현할 수 있게 해준다. 논리 연산자는 피연산자로 boolean형 또는 boolean형 값을 결과로 하는 조건식만을 허용한다.

### 5.1 논리 연산자 - &&, ||, !

논리 연산자 `&&`는 '그리고(AND)'에 해당하며, 두 피연산자가 모두 true일 때만 true를 결과로 얻는다. `||`는 '또는(OR)'에 해당하며, 피연산자 중 어느 한 쪽만 true이어도 true를 결과로 얻는다.

논리 연산자의 연산결과 표는 다음가 같다.

| x | y | x \|\| y | x && y |
|:---:|:---:|:---:|:---:|
| true | true | true | true |
| true | false | true | false |
| false | true | true | false |
| false | false | false | false |

<br/>
논리 연산자를 사용할 때 주의할 점에 대한 몇 가지 예제가 있다.

<span style="font-size:18px">&#10112;</span> x는 10보다 크고, 20보다 작다.

'x > 10'와 'x < 20'가 '그리고(AND)'로 연결된 조건으로 다음과 같이 쓸 수 있다.
<center> x > 10 && x < 20 </center><br/>

'x > 10'은 '10 < x'와 같으므로 가독성 측면에서 다음과 같이 쓸 수 있다.
<center> 10 < x && x < 20 </center><br/>

단, 논리연산자를 생략하고 '10 < x < 20'처럼 쓸 수는 없다.

<span style="font-size:18px">&#10113;</span> i는 2의 배수 또는 3의 배수이다.

어떤 수가 2의 배수라면 2로 나누었을 때 나머지가 0이다. 따라서 나머지연산의 결과가 0인지 확인하면 된다.
<center> i % 2 == 0 || i % 3 == 0 </center><br/>

<span style="font-size:18px">&#10114;</span> i는 2의 배수 또는 3의 배수이지만 6의 배수는 아니다.

이전 조건에 6의 배수를 제외하는 조건이 추가되었다. 추가된 조건을 `&&`로 붙인다.
<center> (i % 2 == 0 || i % 3 == 0) && i % 6 != 0 </center><br/>

괄호를 사용한 이유는 `&&`가 `||`보다 우선순위가 높기 때문이다. 이처럼 `&&`와 `||`가 함께 사용된 경우 괄호를 사용해서 우선순위를 명확히 해주는 것이 좋다.

<span style="font-size:18px">&#10115;</span> 문자 ch는 숫자('0' ~ '9')이다.

입력된 문자가 숫자인지 확인하는 식은 다음과 같다.
<center> '0' <= ch && ch <= '9' </center><br/>

유니코드에서 문자 '0'부터 '9'까지 연속으로 배치되어 있기 때문에 가능한 식이다.

<span style="font-size:18px">&#10116;</span> 문자 ch는 대문자 또는 소문자이다.

<span style="font-size:18px">&#10115;</span>와 마찬가지로 연속적으로 배치되어 있으므로 식은 다음과 같다.
<center> ('a' <= ch && ch <= 'z') || ('A' <= ch && ch <= 'Z') </center><br/>

<p style="color:#a0adec"><b>효율적인 연산(short circuit evaluation)</b></p>

논리연산자의 특징은 효율적인 연산을 한다는 것이다.

OR연산 `||`의 경우, 어느 한 쪽만 <b>참</b>이어도 전체 연산결과가 <b>참</b>이므로 좌측 피연산자가 `true`이면 우측 피연산자의 값은 평가하지 않는다.

AND연산 `&&`의 경우, 어느 한 쪽만 <b>거짓</b>이어도 전체 연산결과가 <b>거짓</b>이므로 좌측 피연산자가 `false`이면 우측 피연산자의 값은 평가하지 않는다.

따라서 같은 조건식이라도 피연산자의 위치에 따라 연산속도가 달라질 수 있는 것이다.

<p style="color:#a0adec"><b>논리 부정 연산자 !</b></p>

피연산자가 `true`이면 `false`, `false`이면 `true`를 결과로 반환하는 연산자이다.
이 연산자를 반복적으로 사용하면 참과 거짓이 차례대로 반복되는데 이를 이용하여 <b>토글 버튼(toggle button)</b>을 구현할 수 있다.

주로 사용되는 곳은 조건문과 반복문의 조건식이다.

### 5.2 비트 연산자 & | ^ ~ << >>
