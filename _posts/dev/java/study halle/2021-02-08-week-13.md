---
layout: post
date: 2021-02-08 09:39:00
title: "13주차 과제: I/O."
description: "study halle"
subject: live study
category: [ java study halle ]
tags: [ java, stream, buffer, channel, input, output ]
use_math: true
comments: true
---

> 해당 글을 [백기선 님의 자바 스터디 13주차 과제](https://github.com/whiteship/live-study/issues/13)를 공부하고 공유하기 위해서 작성되었습니다.

# 목표

자바의 input과 output에 대해 학습한다.

# 학습할 것

+ [스트림(Stream) / 버퍼(Buffer) / 채널(Channel) 기반의 I/O](#입출력-io)
+ [InputStream과 OutputStream](#inputstream과-outputstream)
+ [Byte와 Character 스트림](#byte와-character-스트림)
+ [표준 스트림 (System.in, System.out, System.err)](#표준-스트림)
+ [파일 읽고 쓰기](#파일-읽고-쓰기)

# 입출력 I/O

&nbsp;&nbsp;&nbsp;I/O란 Input과 Output의 약자로 입력과 출력, 간단히 입출력이라고 한다. 입출력은 컴퓨터 내부 또는 외부의 장치와 프로그램 간의 데이터를 주고받는 것을 말한다.

## 스트림(Stream)

&nbsp;&nbsp;&nbsp;자바에서 입출력을 수행하려면, 즉 어느 한 쪽에서 데이터를 전달하려면, 두 대상을 연결하고 데이터를 전송할 수 있는 무언가가 필요한데 이것을 스트림(Stream)이라고 정의했다. 스트림은 TV와 DVD를 연결하는 입력선과 출력선 같은 역할이다.

### 스트림이란 데이터를 운반하는데 사용되는 연결통로이다.

스트림이라는 이름은 연속적인 데이터의 흐름을 물에 비유해서 붙여진 것인데, 여러가지로 유사한 점이 많다. 물이 한쪽 방향만 흐르는 것과 같이 스트림은 단방향 통신만 가능하기 때문에 하나의 스트림으로 입력과 출력을 동시에 처리할 수 없다.

&nbsp;&nbsp;&nbsp;입력과 출력을 동시에 수행하려면 입력을 위한 입력스트림(input stream)과 출력을 위한 출력스트림(output stream), 모두 2개의 스트림이 필요하다.

<img>

스트림은 큐(queue)와 같은 선입선출의 구조이다. 따라서 먼저 보낸 데이터를 먼저 받게 되어있으며 중간에 건너뜀 없이 연속적으로 데이터를 주고받는다.

# InputStream과 OutputStream

&nbsp;&nbsp;&nbsp;스트림은 바이트단위로 데이터를 전송하며 입출력 대상에 따라 여러 종류의 입출력 스트림이 있다. 어떠한 대상에 대해서 작업을 할 것인지 그리고 입력을 할 것인지 출력을 할 것인지에 따라서 해당 스트림을 선택해서 사용하면 된다.

이러한 스트림들은 모두 `InputStream` 또는 `OutputStream`의 자손들이며, 각각 읽고 쓰는데 필요한 추사엠서드를 자신에 맞게 구현해 놓았다.

&nbsp;&nbsp;&nbsp;자바에서는 `java.io`패키지를 통해 많은 종류의 입출력관련 클래스들을 제공하고 있다. 또한 입출력을 처리할 수 있는 표준화된 방법을 제공함으로써 입출력의 대상이 달라져도 동일한 방법으로 입출력이 가능하게 한다.

<table align="center">
  <tr style="text-align:center; background-color:#3a3c42; color:white">
    <td> InputStream </td>
    <td> OutputStream </td>
  </tr>
  <tr>
    <td> abstract int read( ) </td>
    <td> abstract void write(int b) </td>
  </tr>
  <tr>
    <td> int read(byte[ ] b) </td>
    <td> void write(byte[ ] b) </td>
  </tr>
  <tr>
    <td> int read(byte[ ] b, int off, int len) </td>
    <td> void write(byte[ ] b, int off, int len) </td>
  </tr>
</table>

&#128161; read()의 반환타입이 byte가 아닌 int인 이유는 read()의 반환값의 범위가 0 ~ 255와 -1이기 때문이다.

&nbsp;&nbsp;&nbsp;InputStream의 read()와 OutputStream의 write(int b)는 입출력의 대상에 따라 읽고 쓰는 방법이 다를 것이기 때문에 각 상황에 알맞게 구현하라는 의미에서 추상메서드로 정의되어 있다. read()와 write(int b)를 제외한 나머지 메서드들은 read()와 write(int b)를 이용해서 구현한 것들이다.

<img src="/assets/img/study/week1301.png" width="70%" aling="center"><br/>

<img src="/assets/img/study/week1302.png" width="70%" aling="center"><br/>

InputStream의 실제 코드를 살펴보면 `read(byte[] b, int off, int len)`에서 read()를 호출하는 것을 볼 수 있다.

&nbsp;&nbsp;&nbsp;메서드는 선언부만 알고 있어도 호출이 가능하기 때문에, 추상메서드를 호출하는 코드를 작성할 수 있다. 결론적으로 read()는 반드시 구현되어야하는 핵심적인 메서드로, read()가 없으면 나머지 메서드들이 의미가 없다는 것이다.

## 보조 스트림

&nbsp;&nbsp;&nbsp;스트림의 기능을 보완하기 위한 보조스트림들이 제공되는데, 보조스트림은 실제 데이터를 주고받는 스트림이 아니기 때문에 데이터를 입출력할 수 있는 기능은 없다. 하지만 스트림의 기능을 향상시키거나 새로운 기능을 추가할 수 있다.

```java
FileInputStream fis = new FileInputStream("test.txt");

BufferedInputStream bis = new BufferedInputStream(fis);

bis.read();
```

위 코드는 test.txt라는 파일을 읽는 예제이다. 코드 상으로는 보조스트림인 BufferedInputStream이 입력기능을 수행하는 것처럼 보이지만, 실제 입력기능은 BufferedInputStream과 연결된 FileInputStream이 수행하고, 보조스트림인 BufferedInputStream은 버퍼만을 제공한다.

&nbsp;&nbsp;&nbsp;모든 보조스트림 역시 InputStream과 OutputStream의 자손들이므로 입출력방법이 같다.

<table align="center">
  <tr style="text-align:center; background-color:#3a3c42; color:white">
    <td> 입력 </td>
    <td> 출력 </td>
    <td> 설명 </td>
  </tr>
  <tr>
    <td> FilterInputStream </td>
    <td> FilterOutputStream </td>
    <td> 필터를 이용한 입출력 처리 </td>
  </tr>
  <tr>
    <td> BufferedInputStream </td>
    <td> BufferedOutputStream </td>
    <td> 버퍼를 이용한 입출력 성능향상 </td>
  </tr>
  <tr>
    <td> DataInputStream </td>
    <td> DataOutputStream </td>
    <td> int, float와 같은 기본형 단위(primitive type)로 데이터를 처리하는 기능 </td>
  </tr>
  <tr>
    <td> SequenceInputStream </td>
    <td> 없음 </td>
    <td> 두 개의 스트림을 하나로 연결 </td>
  </tr>
  <tr>
    <td> LineNumberInputStream </td>
    <td> 없음 </td>
    <td> 읽어 온 데이터의 라인 번호를 카운트<br/>
    (JDK 1.1부터 LineNumberReader로 대체) </td>
  </tr>
  <tr>
    <td> ObjectInputStream </td>
    <td> ObjectOutputStream </td>
    <td> 데이터를 객체단위로 읽고 쓰는데 사용.<br/>
    주로 파일을 이용하며 객체 직렬화와 관련있음 </td>
  </tr>
  <tr>
    <td> 없음 </td>
    <td> PrintStream </td>
    <td> 버퍼를 이용하며, 추가적인 print 관련 기능 (print, printf, println 메서드) </td>
  </tr>
  <tr>
    <td> PushbackInputStream </td>
    <td> 없음 </td>
    <td> 버퍼를 이용해서 읽어 온 데이터를 다시 되돌리는 기능 (unread, push back to buffer) </td>
  </tr>
</table>

# Byte와 Character 스트림

&nbsp;&nbsp;&nbsp;Byte 스트림은 입출력의 단위가 1byte이다. 자바에서는 한 문자를 의미하는 char형이 2byte이다. 따라서 바이트 스트림으로는 문자를 처리하기 어렵다. 이를 보완하기 위해서 제공되는 Character 스트림, 문자기반 스트림은 입출력의 단위가 2byte이다. 문자데이터를 입출력할 때는 바이트 스트림 대신 문자 스트림을 사용하면 된다.

## Byte 스트림




# 표준 스트림

# 파일 읽고 쓰기

---

# NIO

# NIO(New Input/Output)

의미 그대로 새로운 입출력이라는 의미를 가진다. 기존 I/O의 단점을 개선하기 위해 java 4 부터 추가된 패키지이다.

<table align="center">
  <tr style="text-align:center; background-color:#3a3c42; color:white">
    <td> NIO 패키지 </td>
    <td> 내용 </td>
  </tr>
  <tr>
    <td> java.nio </td>
    <td> 다양한 버퍼 클래스 </td>
  </tr>
  <tr>
    <td> java.nio.channels </td>
    <td> 파일 채널, TCP 채널, UDP 채널 등의 클래스 </td>
  </tr>
  <tr>
    <td> java.nio.channels.spi </td>
    <td> java.nio.channels 패키지를 위한 서비스 제공자 클래스 </td>
  </tr>
  <tr>
    <td> java.nio.charset </td>
    <td> 문자셋, 인코더, 디코더 API </td>
  </tr>
  <tr>
    <td> java.nio.charset.spi </td>
    <td> java.nio.charset 패키지를 위한 서비스 제공자 클래스 </td>
  </tr>
  <tr>
    <td> java.nio.file </td>
    <td> 파일 및 파일 시스템에 접근하기 위한 클래스 </td>
  </tr>
  <tr>
    <td> java.nio.file.attribute </td>
    <td> 파일 및 파일 시스템의 속성에 접근하기 위한 클래스 </td>
  </tr>
  <tr>
    <td> java.nio.file.spi </td>
    <td> java.nio.file 패키지를 위한 서비스 제공자 클래스 </td>
  </tr>
</table>


## IO와 NIO의 차이점

IO와 NIO는 데이터를 입출력한다는 목적은 동일하지만, 방식에서 큰 차이가 나타난다.

<table align="center">
  <tr style="text-align:center; background-color:#3a3c42; color:white">
    <td> 구분 </td>
    <td> IO </td>
    <td> NIO </td>
  </tr>
  <tr>
    <td> 입출력 방식 </td>
    <td> 스트림 방식 </td>
    <td> 채널 방식 </td>
  </tr>
  <tr>
    <td> 버퍼 방식 </td>
    <td> 넌버퍼(non-buffer) </td>
    <td> 버퍼(buffer) </td>
  </tr>
  <tr>
    <td> 비동기 방식 </td>
    <td> 지원 안 함 </td>
    <td> 지원 </td>
  </tr>
  <tr>
    <td> 블로킹 / 넌블로킹 방식 </td>
    <td> 블로킹 방식만 지원 (동기) </td>
    <td> 블로킹 / 넌블로킹 모두 지원 (동기 / 비동기) </td>
  </tr>
</table>

## 스트림과 채널 (Stream vs Channel)

### IO는 스트림(Stream) 기반이다.

스트림은 입력 스트림과 출력 스트림으로 구분되어 있기 때문에 데이터를 읽기 위해서는 입력 스트림을 생성해야 하고, 데이터를 출력하기 위해서는 출력 스트림을 생성해야 한다.

### NIO는 채널(Channel) 기반이다.

채널은 스트림과 달리 양방향으로 입력과 출력이 가능하다.

그렇기 때문에 입력과 출력을 위한 별도의 채널을 만들 필요가 없다.

## 넌버퍼와 버퍼 (non-buffer vs buffer)

IO에서는 출력 스트림이 1바이트를 쓰면 입력 스트림이 1바이트를 읽는다.

이러한 시스템은 대체로 느리다.

이것보다는 `버퍼(Buffer : 메모리 저장소)`를 사용해서 복수 개의 바이트를 한꺼번에 입력받고 출력하는 것이 성능에 이점을 가지게 된다.

그래서 IO는 버퍼를 제공해주는 보조 스트림인 BufferedInputStream, BufferedOutputStream을 연결해 사용하기도 한다.

NIO는 기본적으로 버퍼를 사용해서 입출력을 하기 때문에 IO보다 높은 성능을 가진다.

### IO는 스트림에서 읽은 데이터를 즉시 처리한다.

- 스트림으로부터 입력된 전체 데이터를 별도로 저장하지 않으면, 입력된 데이터의 위치를 이동해 가면서 자유롭게 이용할 수 없다.

### NIO는 읽은 데이터를 무조건 버퍼에 저장한다.

- 버퍼 내에서 데이터의 위치 이동을 해가면서 필요한 부분만 읽고 쓸 수 있다.

## 블로킹과 넌블로킹 (Blocking vs non-blocking)

### IO는 블로킹(Blocking) 된다.

입력 스트림의 read() 메소드를 호출하면 데이터가 입력되기 전까지 Thread는 블로킹(대기상태)가 된다.

마찬가지로 출력 스트림의 write() 메소드를 호출하면 데이터가 출력되기 전까지 Thread는 블로킹된다.

IO Thread가 블로킹되면 다른 일을 할 수 없고 블로킹을 빠져나오기 위해 인터럽트(interrupt)도 할 수 없다.

→ 블로킹을 빠져나오는 유일한 방법은 스트림을 닫는것이다.

### NIO는 블로킹과 넌블로킹(non-blocking) 특징을 모두 가진다.

IO블로킹과 NIO 블로킹과의 차이점은 NIO 블로킹은 Thread를 인터럽트(interrupt) 함으로써 빠져나올 수 있다.

블로킹의 반대개념이 넌블로킹인데, 입출력 작업 시 Thread가 블로킹되지 않는 것을 말한다.

NIO의 넌블로킹은 입출력 작업 준비가 완료된 채널만 선택해서 작업 Thread가 처리하기 때문에 작업 Thread가 블로킹되지 않는다.

→ 작업준비가 완료되었다는 뜻은 지금 바로 읽고 쓸수 있는 상태를 말한다.

NIO 넌블로킹의 핵심 객체는 멀티플렉서(multiplexor)인 셀릭터(Selector) 이다.

셀렉터는 복수 개의 채널 중에서 준비 완료된 채널을 선택하는 방법을 제공해준다.

---
**Reference**
+ [자바의 정석 3/e](http://www.kyobobook.co.kr/product/detailViewKor.laf?mallGb=KOR&ejkGb=KOR&barcode=9788994492032)
+ [Java in a Nutshell](https://www.amazon.com/Java-Nutshell-Desktop-Quick-Reference/dp/1492037257/ref=sr_1_1?dchild=1&keywords=Java+in+a+Nutshell&qid=1605393888&s=books&sr=1-1)
+ [오라클 공식 가이드](https://docs.oracle.com/javase/tutorial/java/TOC.html)
