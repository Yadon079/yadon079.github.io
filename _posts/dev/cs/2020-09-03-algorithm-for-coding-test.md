---
layout: post
date: 2020-09-03 13:20:00
title: "코딩 테스트를 위한 알고리즘"
description: "전략적 접근 및 Tip"
subject: dev
category: [ cs ]
tags: [ cs, algorithm ]
comments: true
---

# Algorithm

+ [코딩 테스트를 위한 Tip](#코딩-테스트를-위한-Tip)
+ [문제 해결을 위한 전략적 접근(문제 접근법)](#문제-해결을-위한-전략적-접근)
+ [Sorting Algorithm(정렬 알고리즘)](#sorting-algorithm)
+ [Prime Number Algorithm(소수 판별법 알고리즘)](#prime-number-algorithm)

## 코딩 테스트를 위한 Tip

> 이 글은 [How to Rock an Algorithm Interview](web.archive.org/web/20110929132042/https://blog.palantir.com/2011/09/26/how-to-rock-an-algorithm-interview/)을 번역한 내용에 기반을 두고 있습니다.

1. 칠판에 글쓰기를 시작하세요.

당연하게 들릴지 모르겠지만, 빈 벽을 쳐다보다 아무것도 못하는 수십 명의 후보자들이 많습니다. 텅 빈 벽을 보면서 아무것도 보지 않는 것보다 문제의 예를 응시하는 것이 더 생산적일 것입니다. 연관된 그림을 생각할 수 있다면 그 그림을 그리세요. 중간 크기의 예제가 있다면 작업할 수 있습니다(중간 크기의 예제는 작은 것보단 낫습니다. 작은 예제로 문제가 풀리는 경우는 흔하지 않기 때문이죠). 혹은 알고있는 몇 가지의 명제를 적어두세요. 아무것도 안하는 것보단 좋습니다.

2. 생각한 것들로 이야기하세요.  

그리고 자신의 소리가 멍청하게 들릴까 걱정하지 마세요. 많은 사람들이 조용히 문제를 생각하는 것을 선호하지만, 때로는 막혔을 때 대화로 해결하는 것이 한 가지 방법이 될 수 있습니다. 가끔은 면접관에게 당신의 진행상황에 대해 명확하게 말하는 것이 무슨 일이 일어나는지 이해하는 계기가 될 수 있습니다. 당신이 강력하게 주장하지 않더라도, 면접관은 당신의 생각을 지속하도록 질문을 중단시킬 수 있습니다. 무엇을 하든 힌트를 위해 면접관을 속이려 하지마세요. 힌트가 필요하다면, 정직하게 그것에 대해 질문하세요.

3. 알고리즘을 생각하세요.

때때로 문제의 세부 사항을 검토하고 거기서 해결책이 나오기를 기대하는 것이 좋습니다(이것은 상향식 접근법일 것입니다). 그러나 다른 알고리즘에 대해 생각해 볼 수도 있고 각각의 알고리즘이 눈 앞의 문제에 적용되는지 물어볼 수 있습니다(하향식 접근법). 이렇게 참조 프레임을 변경하면 종종 즉각적인 통찰력을 얻을 수 있습니다. 다음 알고리즘 기법들은 면접에서 요구하는 문제의 절반 이상을 해결하는데 도움이 될 것입니다.

+ Sorting (plus searching / binary search) : 정렬 (이진 탐색)
+ Divide and Conquer : 분할 정복
+ Dynamic Programming / Memoization : 동적 프로그래밍
+ Greediness : 탐욕 알고리즘
+ Recursion : 재귀 알고리즘
+ Algorithm associated with a specific data structure : 특정 데이터 구조와 관련된 알고리즘(4번째 목차로...)

4. 데이터 구조를 생각하세요.

상위 10개 데이터 구조가 현실에서 사용되는 데이터 구조의 99퍼를 차지한다는 것을 알고 계셨나요? 물론 농담입니다. 때로는 `블룸 필터` 또는 `접미어 트리`를 최적의 솔루션으로 하는 문제를 질문합니다. 하지만 이러한 문제조차도 훨씬 더 일반적인 데이터 구조를 최적의 솔루션으로 사용하는 경향이 있습니다. 다음 데이터 구조들은 가장 자주 표시되는 것들입니다.

+ Array
+ Stack / Queue
+ HashSet / HashMap / HashTable / Dictionary
+ Tree / Binary Tree
+ Heap
+ Graph

이러한 데이터 구조의 안과 밖을 알아야 합니다. 삽입/삭제/조회 특성은 무엇인가요?(예를 들어, 균형 잡힌 이진 트리의 경우 `O(log n)`입니다.) 일반적인 주의사항은 무엇인가요?(Hashing은 까다롭고, 일반적으로 해시되는 물체의 크기가 `k`일 경우 `O(k)` 시간이 걸립니다.) 각 데이터 구조와 함께 사용되는 알고리즘은 무엇인가요?(그래프의 경우 `Dijkstra`(다익스트라)입니다.) 하지만 당신이 이러한 데이터 구조를 이해하게 되면, 올바른 데이터 구조를 사용하는 순간 종종 문제에 대한 해결책이 당신의 마음속에 떠오를 것입니다.

5. 이전에 보았던 관련 문제와 해결 방법에 대해 생각해보세요.

여러분이 받은 문제는 이전에 보았거나 혹은 그와 유사한 문제일 가능성이 있습니다. 예전 문제들의 해결책들을 어떻게 문제의 세부 사항에 적용할 수 있을지 생각해보세요. 문제가 제시된 형태에 사로잡히지 마세요! 핵심에 맞춰서 과거의 해결책과 일치하는지 확인하세요.

6. 문제를 작은 문제로 나누어서 수정하세요.

문제의 특별한 경우 또는 단순한 버전을 해결하려고 시도하세요. 코너 케이스를 보는 것은 문제의 복잡성과 범위를 제한하는 좋은 방법입니다. 문제를 큰 문제의 하위 집합으로 줄이면 기초부터 시작하여 전체 범위까지 작업을 할 수 있습니다. 문제를 작은 문제의 구성으로 보는 것도 도움이 됩니다. 예를 들어, "알 수 없는 상수 k에 의해 주기적으로 이동되는 정렬된 배열에서 숫자 찾기"는 (1) 먼저 "k"를 알아낸 다음 (2) 이동된 배열에서 이진 검색을 수행하는 방법을 알아내 해결 할 수 있습니다.

7. 되돌아 오는 것을 두려워하지 마세요.

특정 접근법이 효과가 없다고 느껴져서 다른 접근 방식을 시도할 때가 있습니다. 물론 쉽게 포기해서는 안됩니다. 하지만 당신은 결실도 없고 유망함이 느껴지지 않는 접근법에 시간을 허비했다면, 뒤로 물러나 다른 작업을 시도해보세요. 저는 덜 접근한 지원자보다 멀리 나아간 지원자를 더 많이 보았고, 이것은 당신이(당신과 같은 다른 이들 모두) 비논리적인 접근법을 포기해야 한다는 것입니다.

---

## 문제 해결을 위한 전략적 접근

### 코딩 테스트의 목적

1. 문제 해결 여부
2. 예외 상황과 경계값 처리
3. 코드 품질(코드 가독성과 중복 제거 여부 등)
4. 사용 언어 이해도
5. 효율성

최종적으로는 문제 해결 능력을 측정하기 위함이며 이는 <b>어떻게 이 문제를 창의적으로 해결할 것인가</b>를 측정하기 위함이라고 볼 수 있다.

### 접근하기

1. 문제를 공격적으로 받아들이고 필요한 정보를 추가적으로 요구하여, 해당 문제에 대해 완벽하게 이해하는게 우선이다.
2. 해당 문제를 익숙한 용어로 재정의하거나 문제를 해결하기 위한 정보를 추출한다.(추상화)
3. 추상화된 데이터를 기반으로 문제 해결 계획을 세운다. 이 때 사용할 알고리즘과 자료구조를 고민한다.
4. 세운 계획에 대한 검증을 해본다. `sudo`코드 작성을 할 수도 있고 문제 출제자에게 의견을 물어볼 수도 있다.
5. 계획을 통해 문제를 해결해본다. 해결이 되지 않는다면 앞선 과정을 되짚어본다.

### 생각할 때

+ 비슷한 문제를 생각해본다.
+ 단순한 방법을 시작해서 점진적으로 개선한다.
+ 작은 값을 생각해본다.
+ 그림으로 그려본다.
+ 수식으로 표현해본다.
+ 순서를 강제해본다.
+ 뒤에서부터 생각해본다.

### 문제 접근법

<b>Data structure</b>

+ 배열 : 임의의 사이즈를 선언한다.(Heap, Queue, Binary Tree, Hashing 사용)
+ 스택 : 행 특정조건에 따라 push, pop 사용한다.
+ 큐 : BFS(너비 우선 탐색)를 통해 순서대로 접근할 때 적용한다.
+ 연결리스트 : 배열 구현, 포인터 구현 2가지 방법 - 삽입, 삭제가 많이 일어날 때 활용한다.
+ 그래프 : 경우의 수, 연결 관계가 있을 때 사용한다.
+ 해싱 : 데이터 수만큼 메모리에 생성할 수 없는 상황에 적용
+ 트리 : Heap과 BST(이진 탐색)

<b>Algorithm</b>

+ ★재귀(Recursion) : 가장 많이 활용된다. 호출 횟수를 줄이는 것이 중요!(반복 조건, 종료 조건 체크)
+ ★BFS(너비), DFS(깊이) : 2차원 배열에서 확장 시, 경우의 수를 탐색할 때 구조체(class)와 visited 체크를 사용한다.
+ ★정렬 : Quick Sort, Merge(병합) Sort가 대표적이지만, 보통 Quick Sort를 사용한다.
+ ★메모이제이션(Memoization) : 이전 결과가 또 사용될 때, 반복 작업을 안하도록 저장한다.
+ ★이분탐색(Binary Search) : `log N`으로 시간복잡도를 줄일 수 있는 간단하면서 핵심적인 알고리즘이다.
+ 최소 신장 트리(MST) : 사이클이 포함되지 않고 모든 정점이 연결된 트리에 사용한다.(크루스칼, 프림)
+ 최소 공통 조상(LCA) : 경우의 수에서 조건이 겹치는 경우, 최단 경로 탐색시 공통인 경우가 많을 때 사용한다.
+ 서로소 집합(Disjoint-Set) : 인접한 집합의 모임으로 Tree의 일종이며 시간복잡도가 낮다.
+ 분할 정복 : Merge Sort에 사용되며 범위를 나누어 확인할 때 사용한다.
+ 트라이(Trie) : 모든 String을 저장하면서 비교하는 방법이다.
+ 비트마스킹 : `|는 OR, &는 AND, ^는 XOR`를 통해 메모리를 절약할 수 있다.

![sort](/assets/img/cs/sort-time.png)

### 해결 방법 분류

<b>DP(동적 계획법)</b>

복잡한 문제를 간단한 여러 개의 하위 문제(sub-problem)로 나누어 푸는 방법이다.

DP에는 두 가지 구현 방식이 존재한다.

+ `top-down` : 문제를 풀다가 하위 문제(sub-problem)가 풀리지 않았을 때 하위 문제를 풀기 시작한다. 재귀 함수로 구현하는 경우 대부분 `top-down` 방식이다
  + 같은 하위 문제를 가지고 있는 경우가 존재한다. 해당 최적해를 저장해서 사용하는 경우 하위 문제 수가 기하급수적으로 증가할 때 유용하다. 이러한 방법을 <b>Memoization</b>이라고 한다.
+ `bottom-up` : `top-down`과 반대로 하위 문제들을 먼저 해결하여 상위 문제를 푼다.

<b>예시 - Fibonacci 수열</b>

```
top-down
f (int n) {
  if n == 0 : return 0
  elif n == 1 : return 1
  if dp[n] has value : return dp[n]
  else : dp[n] = f(n - 2) + f(n - 1)
         return dp[n]
}
```

```
bottom-up
f (int n) {
  f[0] = 0
  f[1] = 1
  for(i = 2; i <= n; i++) {
    f[i] = f[i - 2] + f[i - 1]
  }
  return f[n]
}
```

<b>Greedy(탐욕법)</b>

모든 선택지를 선택해보고 그 중 가장 좋은 것을 찾는 방법이 `Divide and Conquer(분할 정복)`와 `DP(동적 계획법)`였다면 `Greedy(탐욕법)`는 각 단계마다 그 순간 선택할 수 있는 최선을 선택하는 해결 방법이다. 탐욕법은 동적 계획법보다 수행 시간이 훨씬 빠르다. 하지만 많은 경우에 최적해를 찾지 못하고 이를 적용할 수 있는 경우가 두 가지로 제한된다.

1. 탐욕법을 사용해도 항상 최적해를 구할 수 있는 경우
2. 시간이나 공간적 제약으로 최적해 대신 근사해를 찾아서 해결하는 경우

---

## Sorting Algorithm

Sorting 알고리즘은 크게 Comparisons 방식과 Non-Comparisons 방식으로 나눌 수 있다.

### Comparisons Sorting Algorithm(비교 방식 알고리즘)

`Bubble sort`, `Selection Sort`, `Insertion Sort`, `Merge Sort`, `Heap Sort`, `Quick Sort`
