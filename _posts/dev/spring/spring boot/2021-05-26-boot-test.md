---
layout: post
date: 2021-05-26 09:45:00
title: "스프링 부트 활용 : 테스트"
description: "스프링 부트 개념과 활용"
subject: Spring Boot
category: [ spring boot ]
tags: [ spring, boot, test, mockbean ]
use_math: true
comments: true
---

# 스프링 부트 활용

## 테스트

&nbsp;&nbsp;&nbsp;프로젝트를 할 때 항상 코드를 작성하는데 있어서 TDD가 강조된다. TDD란 <b>Test-Driven Development</b>(테스트 주도 개발)의 약자로, "테스트가 개발을 이끌어 나간다"고 정의할 수 있다. 스프링 부트에서는 테스트 코드를 작성하기 편리한 기능들이 많이 제공되고 있으므로, 예제를 보면서 알아보자.

우선 스프링 부트에서 테스트 환경을 구성하기 위해서 `spring-boot-starter-test` 의존성을 추가한다. 프로젝트를 생성할 때 기본적으로 추가를 해주기는 하지만 간혹 없는 경우도 있으니 의존성을 확인하도록 하자.

<img src="/assets/img/boot/test01.png" width="50%" height="auto" align="center"><br/>

## 테스트 예제

&nbsp;&nbsp;&nbsp;Controller를 하나 만들어서 Service를 호출한 뒤 `/hello`라는 요청을 보내면 hello + [text]가 출력되는 예제를 만들어 보자.  
먼저, SampleController와 SampleService를 만든다.

&#9654; SampleController.java

```java
package me.gracenam.springtestdemo.sample;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class SampleController {

    @Autowired
    private SampleService sampleService;

    @GetMapping("/hello")
    public String hello() {
        return "hello " + sampleService.getName();
    }

}
```

&#9654; SampleService.java

```java
package me.gracenam.springtestdemo.sample;

import org.springframework.stereotype.Service;

@Service
public class SampleService {

    public String getName() {
        return "grace";
    }

}
```

&nbsp;&nbsp;&nbsp;이제 Controller 클래스가 잘 동작하는지 확인하기 위해서 테스트해보고 싶다. SampleControllerTest 파일을 만들자. test 디렉토리 아래에 직접 만들어도 되고 SampleController 클래스에서 <b>Command + N</b>를 눌러서 만들어도 된다. 인텔리제이의 경우 <b>Command + Shift + T</b>로 만들 수 있다.

<img src="/assets/img/boot/test02.png" width="50%" height="auto" align="center"><br/>

Test를 실행하기 위해서는 `spring-boot-starter-test` 의존성이 필요하기 때문에 꼭 확인하도록 하자.

&#9654; SampleControllerTest.java

```java
package me.gracenam.springtestdemo.sample;

import org.junit.jupiter.api.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.junit4.SpringRunner;
import org.springframework.test.web.servlet.MockMvc;

import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

@RunWith(SpringRunner.class)
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.MOCK)
@AutoConfigureMockMvc
class SampleControllerTest {

    @Autowired
    MockMvc mockMvc;

    @Test
    public void hello() throws Exception {
        mockMvc.perform(get("/hello"))
                .andExpect(status().isOk())
                .andExpect(content().string("hello grace"))
                .andDo(print());
    }

}
```

`@RunWith(SpringRunner.class)`와 `@SpringBootTest`, 이 두 애노테이션이 붙어있는 것이 테스트 코드의 가장 기본적인 형태이다. 이 코드를 보고 '빈 설정 파일은 설정을 안해주는 것인가?'라는 의문이 생길 수 있다. 이 부분은 걱정할 필요가 없는데 `@SpringBootApplication`에서 알아서 찾아주기 때문이다.

```java
...

@RunWith(SpringRunner.class)
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.MOCK)
@AutoConfigureMockMvc
class SampleControllerTest {

    @Autowired
    MockMvc mockMvc;

    ...
```

`@RunWith`는 JUnit의 테스트 러너를 확장하는 방법 중 하나로 커스텀 테스트 러너를 설정해주는 방법이다. 테스트를 진행할 때 JUnit에 내장된 실행자 외에 다른 실행자를 실행시킨다. 위 코드에서는 <b>SpringRunner.class</b>를 설정했기 때문에 SpringRunner라는 스프링 실행자를 사용한다. 이처럼 `@RunWith`는 스프링 부트 테스트와 JUnit 사이에서 연결자 역할을 한다.  

&#128161; JUnit5 부터는 `@RunWith`을 사용하지 않는데 그 이유에 대해서는 기선님이 작성하신 [스프링 부트, @RunWith가 더 이상 보이지 않는 이유](https://www.whiteship.me/springboot-no-more-runwith/)를 참고하자.

`@SpringBootTest`는 `@RunWith`과 함께 사용해야한다. 이 애노테이션에는 <b>webEnvironment</b>라는 속성이 있는데 이 속성의 기본 값은 <b>MOCK</b>으로 되어있다. 속성의 값은 다음과 같다.

+ MOCK : mock servlet environment. 내장 톰캣을 사용하지 않음.
+ RANDOM_PORT / DEFINED_PORT : 내장 톰캣을 사용함.
+ NONE: 서블릿 환경을 제공하지 않음.

여기서 사용하는 Mock에 대해서 조금 더 알아보자.

## Mock 타입 테스트

&nbsp;&nbsp;&nbsp;Mock 타입은 Servlet Container(톰캣, jetty 등등)를 테스트용으로 띄우지 않고, Mockup[^1}을 해서 Servlet을 Mocking[^2]한 것을 띄워준다. dispatcherServlet이 생성은 되지만 Mockup이 되기 때문에, dispatcherServlet에 요청을 보낸 것<b>'처럼'</b> 테스트를 할 수 있다. 이 때 mockup 된 Servlet과 상호작용을 하려면 MockMVC라는 클라이언트를 사용해야 한다.

MockMVC라는 클라이언트를 사용하려면 `@AutoConfigureMockMvc` 애노테이션을 추가하고 `@Autowired`를 사용해서 주입받는 방법이 가장 쉽다. 이 외에도 여러가지 방법이 있는데 스프링 부트 최신 버전에서 MockMVC를 만드는 방법은 애노테이션을 추가하는 것이 가장 쉽다.

&nbsp;&nbsp;&nbsp;이제 테스트를 작성하면 된다.

```java
    ...

    @Test
    public void hello() throws Exception {
        mockMvc.perform(get("/hello"))
                .andExpect(status().isOk())
                .andExpect(content().string("hello grace"))
                .andDo(print());
    }

}
```

테스트하고 싶은 메소드에 `@Test`를 붙이면 해당 메소드를 테스트 대상으로 지정할 수 있다.

`perform()` 메소드는 입력된 값을 수행하는 메소드로 여기서는 `MockMvc.perform(get())`의 형태로 작성하였는데 해석하면 MockMvc(MockMvc.)에 요청(get)을 보내는 것(perform)이다. 이 때 에러가 발생할 수 있기 때문에 throws Exception을 추가한다.  
`andExpect()`는 예상 값을 검증하는 메소드로 `status().isOk()`인지를 검증하는 것이다. `status().isOk()`는 status의 코드가 200, 정상인지 확인하는 것이다. 이어서 `content().string()`은 출력되는 결과 값이 expectedContent, 여기서는 "hello grace"라고 주어진 값과 동일한지 확인하는 것이다.  
마지막으로 `andDo()`는 요청에 대한 처리를 해주는 메소드다. 일반적으로 print() 메소드가 들어온다.  
이 외에도 어떤 Controller를 썼는지, 어떤 Controller의 어떤 method를 호출했는지, 이 요청이 이 Controller에 제대로 맵핑이 되었는지 등의 다른 옵션들도 존재한다.

정상적으로 테스트 코드를 작성했다면 테스트 코드 실행 시 아래와 같이 출력되는 것을 볼 수 있다.

<img src="/assets/img/boot/test03.png" width="70%" height="auto" align="center"><br/>

## RANDOM_PORT / DEFINED_PORT 타입 테스트

&nbsp;&nbsp;&nbsp;RANDOM_PORT를 사용하면 실제 Servlet Containter인 내장 톰캣이 뜬다. 이 때부터는 MockMvc가 아니라 테스트용 REST template이나, 테스트용 web Client를 사용해야 한다.

<span style="font-size:16pt"><b>&#9654; RestTemplate</b></span>

&nbsp;&nbsp;&nbsp;RestTemplate을 먼저 살펴보자. MockMvc 대신 <b>TestRestTemplate</b>을 주입받는다. 

```java
...

@RunWith(SpringRunner.class)
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@AutoConfigureMockMvc
class SampleControllerTest {

    @Autowired
    TestRestTemplate testRestTemplate;

    @Test
    public void hello() throws Exception {
        String result = testRestTemplate.getForObject("/hello", String.class);
        assertThat(result).isEqualTo("hello grace");
    }

}
```

테스트 코드를 작성한다. url을 주고(/hello), 원하는 바디 타입을 준 다음(String.class), 이 값을 assertThat으로 확인한다.

<img src="/assets/img/boot/test03.png" width="50%" height="auto" align="center"><br/>

이렇게 할 경우 SampleService단 까지 가기 때문에 테스트가 다소 길어진다. 만약 SampleController까지만 테스트 하고 싶을 때는 어떻게 할까?

### @MockBean

`@MockBean`이라는 애노테이션이 있다. 이 애노테이션을 사용하면 application context 안에 들어있는 빈을 MockBean으로 교체한다.

---
**Reference**
+ [스프링 부트 개념과 활용](https://inf.run/Xny5)
+ [공식 문서](https://docs.spring.io/spring-boot/docs/2.0.3.RELEASE/reference/htmlsingle/)

---
[^1]:Mocking한 객체를 메모리에서 얻어내는 과정.
[^2]:테스트를 위해 실제 객체와 비슷한 모의 객체를 만드는 것.